https://docs.gradle.org/current/dsl/index.html
source code: https://github.com/bmuschko/gradle-in-action-source


gradle从2012开始起步；
build项目的工具链；
polyglot builds: 项目由多种语言构成；
A build：要么产生一个包，要么消费一个包；
groovy语言体系庞大，不建议专门学习，了解基础即可,<groovy in action>有900多页；


Part 1  Introducing Gradle
chapcter 1. Introduction to project automation
Ant and Maven:两个java项目自动化的传统工具；
1.1 Life without project automation
IDE环境不统一（编译器等）；代码没提交；URL没配对；
当测试的时候，开发没事干；因为未预见的问题，部署慢；
手工操作的事务多；
1.2 Benefits of project automation
以一种可重复和一致的方式交付软件；
不要手工干涉，能自动化的就要自动化；
可重复，可靠，可移植；
shell不满足可移植的条件；
自动构建触发时机：
	当需要时；
	当某事件出现时(比如check in)；
	计划任务（特定间隔或特定时间）；
一般过程：
	编译源码；
	拷贝class文件到目标目录；
	打包；
所有任务组成有向无环图；directed acyclic graph(DAG)（数据结构：节点->一个任务，有向边->表示任务依赖）

BUILD FILE：包含了构建所需的配置信息，外部第三方库，指令信息；
BUILD INPUTS AND OUTPUTS：一个任务可能会产生输出，也可能以另一个任务的输出作为输入；
构建引擎：构建引擎把build file转化为内部模型；
依赖管理器（DEPENDENCY MANAGER）：从外部环境(http server、本地文件系统)获得相应的依赖包；
传递式依赖：依赖的metadata存入在repository中，自动处理依赖传递；

1.5 Java build tools
Ant：用于典型任务，提供预定义的任务，可自己扩展标签，写XML，没有依赖管理器（但可集成Ivy依赖管理器），；
	project->target(依赖depends=，ant调用)->task(标签名，如javac,mkdir等标签，辅助信息通过签标属性)
	对build文件结构没有要求，比如源在哪里，目的在哪里，灵活；
	XML文件很长，不好维护，写控制结构if..else困难，没有标准项目结构，没有API，没有依赖管理Ivy.
	
Maven: 标准化的项目布局，统一的构建生命周期；约定大于配置；能生成java doc；使用插件扩展功能；
标准布局：
	src/main/java
	src/main/resources
	src/test/java
	src/test/resources
	target
build file: pom.xml;
标准构建生命周期(8步)：
validate项目定义-》compile-》UT-》package-》集成测试IT-》verification checks-》本地归档-》远端归档
有依赖管理：使用XML的依赖配置块申明，三维坐标（组织名，包名，版本号）
Maven信息管理器下载依赖及依赖传递到本地(.m2 repository)，以便重用；
外部默认为Maven Central；但也可以依赖其它的maven项目；
缺点：
	标准布局和标准生命周期对你的项目可能不适用；写插件难；
下一代工具 gradle：
	易表达，申明式，好维护；有标准，可定制；多个子项目集成构建(多项目构建)；依赖管理；可导入现存的ant/maven脚本；可扩展，高性能；

chapter 2: Next-generation builds with Gradle	
gradle使用groovy而不是XML;
Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，
该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。(百度百科)
To get started with Gradle, all you need to bring to the table is a good understanding of the Java programming language.
JVM-language build tools
continuous delivery deployment pipeline


chapter 3 Building a Gradle project by example	
预定义的项目结构
Gradle wrapper
Introducing the case study：任务管理应用，没有UI，从控制台操作；
gradle自带Java plugin；
apply plugin: 'java'   --》使用java插件；	


java插件会在src/main/java找源码；build.gradle与src平级；
自动设置项目结构的插件：https://github.com/townsfolk/gradle-templates
apply plugin: 'java'   --》使用java插件；-》多一个build任务-》compiles, runs your tests, and assembles
gradle build；会执行12个任务；标记为UP-TO-DATE的任务被忽略（incremental build的功能）；
完成后与src平级多一个build目录，这个层级称为root level；
src的父目录名很重要，是项目的名称；
输出的jar包在build/libs，jar包是项目名称；
Gradle’s Build Language Reference：http://www.gradle.org/docs/current/dsl/
查看可配置的属性：gradle properties
java -jar build\libs\listing_03_04-todo-app-changing-properties-0.1.jar;
DSL元素：sourceSets.main.java.scrDirs/sourceSets.test.java.srcDirs/buildDir这些DSL元素可以修改默认位置；
two DSL configuration elements: repositories and dependencies；
gradle要求必须要定义一个repository: repository{...}；
mavenCentral()：menven的repository;
定义依赖： dependencies{ 组标识，名字，版本号};
比如：dependencies {compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.1'}
查询依赖：http://search.maven.org/
两个gradle插件：War and Jetty：  java 插件->war插件->jetty插件或tomcat插件； 
自带war插件和jetty插件；
apply plugin: 'war'
Web应用的缺省目录：src/main/webapp（再下面是WEB-INF，css和jsp目录）；src/main/java；
Servlet依赖：providedCompile，由运行时环境提供的编译，运行时环境指jetty或tomcat,所以这些依赖不打包在war中;
runtime: 不需要编译，但运行时需要，会打在war中；
dependencies closure：指 dependencies｛...｝
查看一个war的目录结构：jar tf todo-webapp-0.1.war；
webAppDirName=src/main/webapp --》webAppDirName=webfiles
war {from 'static'}：把static目录下的东西加到war的根目录下；
War plugin DSL guide
jetty插件：apply plugin: 'jetty' ：jetty插件使用war的信息；
运行任务名： gradle jettyRun；
访问：http://localhost:8080/todo-webapp-jetty
进程会一直运行，直到Ctrl + C终止；
JRebel：可更新class文件，实现热部署；jetty插件可更新静态文件和jsp文件，无需重启容器；
自定义：jettyRun {httpPort = 9090 contextPath = 'todo'}
Gradle wrapper：create reliable and reproducible builds independent of the operating system, system setup, or installed Gradle version.
wrapper作用：没有装gradle的，可以装；已装了的机器，可以保证版本一致；
一般要求强制使用；
加任务： task wrapper(type: Wrapper) {gradleVersion = '1.7'}
执行：gradle wrapper
gradlew：用于linux系统；
gradlew.bat：用于widow系统 --》gradlew.bat jettyRun
下载的gradle版本的位置：$HOME_DIR/.gradle/wrapper/dists
task wrapper(type: Wrapper) {
gradleVersion = '1.2'
distributionUrl = 'http://myenterprise.com/gradle/dists' //从哪里下载gradle版本
distributionPath = 'gradle-dists' //解包放在哪里，相对路径，相对于gradle的home目录
}
访问：http://localhost:8080/<项目名>
Key to knowing your options are the Gradle DSL and API documentation!!!
标准插件用户指南：http://www.gradle.org/docs/current/userguide/standard_plugins.html


chapter 4 Build script essentials
4.1 Building blocks
gradle的构建块：projects, tasks, and properties.
每一个build至少有一个project;project里面有一个或多个task;在project和task中，会暴露properties.
This interface is the main API you use to interact with Gradle from your build file. 
From a Project, you have programmatic access to all of Gradle's features.
接口名：org.gradle.api.Project；
project变量不是用来访问该项目的属性和方法的，而是你产生这个实例变量；
一个project可以依赖另一个project；一个task可以依赖另一个task;
domain-driven design (DDD)
project:表示你试图build出来的组件,比如jar，或者你试图达到的目标，比如部署应用；
启动build时，会基于build.gradle文件实例化org.gradle.api.Project（接口），用“project”变量名访问(显式或隐式调用)；
project对象可以创建任务，加依赖和配置，应用插件和其它脚本，配置属性，所有功能都包括；
task（org.gradle.api.Task，接口）: task的action和task的依赖；
action: 一个原子操作；
Project和Task有属性（properties）；
自定义属性放在project.ext名字空间，但访问时使用ext空间是可选的；
project.ext.myProp = 'myValue'   《====》 ext {someOtherProp = 123}
在文件中写脚本，就是在project空间下工作；
gradle属性文件：可通过属性文件直接注入到project中；ext.versionFile = file('version.properties')
在<USER_HOME>/.gradle/gradle.properties只能有一个这个文件，另一个地方是根目录: 
在多项目环境下，可以注入属性到所有项目的project对象；
$someOtherProp: 嵌入式变量，使用当前scope内的变量；
■ Project property via the –P command-line option
■ System property via the –D command-line option
■ Environment property following the pattern
ORG_GRADLE_PROJECT_propertyName=someValue
新创建任务task类型：org.gradle.api.DefaultTask是Task接口的标准实现;
不是你写的任务，你也可以加自己的东西；
SNAPSHOT: 还在开发中的快照；
在任务创建后加<任务对象>.doFirst():插在最前面；加<任务对象>.doLast():插在最后面；
QUIET是logger的一个日志级别；
在一个list的依赖列表中，任务的执序顺序是未决的。
4.2.5 Finalizer tasks
task first << { println "first" }
task second << { println "second" }
first.finalizedBy second   //second是Finalizer任务
POGOs, Groovy’s equivalent to POJOs；
Task configuration没有action的定义；
Task configuration blocks are always executed before task actions.
three distinct lifecycle phases are run: initialization,configuration, and execution.
在每一次build时，配置代码都要被执行；
Tasks that are considered up to date are skipped.
通过比较task的输入输出来确定up to date.


















appendix B Groovy for Gradle users
java-->DSL-->gradle
使用方式：
	直接使用groovy脚本代码；
	编译成java字节码使用；
推荐：Groovy in Action, Second Edition
groovy的有意义的缺省：
	尾部的分号是可选的；
	类，构造函数和方法默认public;
	方法体的最后一个表达式被返回，不需要写return;
	groovy编译器自动加getter/setter;
	通过这些getter/setter方法，类的属性可以用点记法访问；
	使用==判断相等；
def： 意为java.lang.Object的占位符（optional typing）；
方法签名可以省略括号，这符合DSL习惯；
string: 单引号，双引号，三引号；
嵌入式变量或表达式(GStrings)：在双引号方式中，使用${};
LISTS: [a,b,c] ==>java.util.ArrayList;
<<  : 加新元素到list;
MAPS: ['a': 2,b:4] ==>java.util.LinkedHashMap
Named parameters: 
Closures:类型是groovy.lang.Closure的代码块，类似于lambdas表达式，可以分配给变量，传给方法，或象方法一样调用；
	隐式闭包参数：没有定义参数的闭包有一个隐式参数it可以访问，它指向调用此闭包的第一个参数，如没有则为null;
	显示闭包参数：
def incrementMajorProjectVersion = { ProjectVersion version ->
    version.major++
}
incrementMajorProjectVersion2是变量名， ｛｝是闭包，'ProjectVersion version ->' 是显式闭包参数，参数类型通常不写，
调用：
	ProjectVersion projectVersion = new ProjectVersion(major: 1, minor: 10)
	incrementMajorProjectVersion(projectVersion)
闭包返回值：return,最后一句(可能是null);
闭包作为方法参数：
CLOSURE DELEGATION：
	闭包是基于闭包委派来执行的，委派是闭包的owner;
	如果在groovy script中写闭包，owner是groovy.lang.Script的实例；
	闭包有一个隐式变量名：‘delegate’，指向owner，可以修改值；
each Gradle comes with a DSL written in Groovy for modeling typical build concerns.
定制任务：一个执行任务+一个增强任务（配置属性）
需要最近的稳定版本的备份；
A distribution is a ZIP file that consists of your web application archive, all source files,and the version property file.
task types Zip and Copy，见DLS；
task rule：executes specific logic based on a task name pattern. //increment<Classifier>Version
TaskContainer












	




