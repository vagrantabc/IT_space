申明：若需转载，请注明出处：

下面的页面包括了所有与该版本相关的官方维护资源：
https://code.angularjs.org/1.5.5/docs/guide

chapter 1 介绍
什么是Angular?
1. library：你的代码主导；
2. frameworks：框架主导；
3. angularjs两者都不属于；
一个完整的客户端解决方案
1. angularjs适合于CRUD的web app.
2. 游戏类和GUI编辑器大量操作DOM，使用jquery更好些，不适合angularjs.
angularjs之禅
1. angularjs是申明式代码，不是命令式代码；
2. 解耦DOM操作与业务逻辑；
3. 代码结构不好，就不好测试，重视可测试性；
4. 解耦客户端代码和服务器端代码；
5. 框架支持设计UI，开发业务，测试；
angularjs的好处：
1. 去掉了注册回调的脚手架代码，更简洁；
2. 不再经常操作底层的DOM；
3. 数据从服务器到DOM对象到UI更加流畅；
4. 启动，初始化简单；

chapter 2 概念总览：
1. 模板：带有额外标记的html;
2. 指令：定制的属性和元素，用于扩展html;
3. 模型：在视图中显示给用户的，并与用户交互的数据；
4. scope: 模型存储的上下文，以便指令，控制器和表达式能访问数据模型；
5. 表达式：在scope中访问变量和函数；
6. Compiler：编译模板，实例化指令和表达式；
7. Filter：格式化显示给用户的表达式的值；
8. 视图：用户看到的东东（DOM）；
9. 数据绑定：在模型和视图之间同步数据；
10. 控制器：视图后面的业务逻辑；
11. 依赖注入：创建和包绕对象和函数；
12. Injector：依赖注入的容器；
13. 模块：一个包括了控制器、filter、服务、指令等不同app部分的容器，容器中的各部分用于配置infector；
14. 服务：独立于视图的可重用的业务逻辑；

数据绑定：
1. 用angularjs写的html就叫模板；
2. 模板经过编译器加载，变形，渲染后就成为视图；
3. 在angularjs中，只有指令可以直接访问DOM，如要访问DOM，就需要自定义指令；
添加UI逻辑：控制器
1. 控制器可以暴露变量和函数给表达式和指令；
2. InvoiceController as invoice：实例化一个控制器，变量名为invoice.
独立于视图的业务逻辑：服务
1. 用到了依赖注入；
2. DI容量就是Infector;
3. angularjs.module（）管理注册；
4. angularjs启动时，它先去加载与ng-app同名的模块，再链式解决下面的依赖模块；
访问后端：
1. 使用自定义的服务去访问后端；

chapter 3 数据绑定
1. 模型与视图的数据双向绑定；
2. 编译后的html是一个双向绑定的活视图；
3. 视图只是模型的一个简单的投射；
4. 控制器看不到视图，易于测试；

chapter 4 控制器
1. 用一个js的构造函数定义，即.controller()方法，用于增强scope;
2. ng-controller指令把控制器构造函数绑定到DOM，并初始化构造器对象；
3. 初始化时，一个子$scope会被创建，并注入到构造器对象中。
4. controller as，这个构造器实例将做为$scope的一个属性；
5. 使用控制器：给$scope添加状态和函数；
6. 不要操作DOM以反映显现逻辑；
   不要格式化输入（使用form控制）和输出（使用filter）;
   不要在控制器之间共享状态（使用服务）；
   不要管理组件（如服务）的生命周期；
设置$scope对象的初始状态
1. 即给$scope对象绑定属性；
2. 在控制器注册后，$scope对象的这些属性即可作为视图模型，被模板所用；
3. 使用ng-controller指令绑定到DOM；
4. 在模板中使用$scope对象的属性绑定表达式；
给$scope对象添加行为
1. 即给$scope对象添加方法；
2. ng-model会给$scope绑定一个变量名；
3. 反之，任何$scope的属性（包括方法）都可被表达式或事件处理指令调用；
正确使用控制器
1. 一个控制器只应该包括一个视图的业务逻辑；
2. 把复杂的业务逻辑封装到服务中，通过依赖注入调用服务；
把控制器与scope对象关联
1. 通过ng-controller指令；
2. 通过$route服务；
3. 通常约定，控制器命名以大写字母开头，以Controller结尾；
4. 控制器的方法可以带参数；
5. 简单的绑定model到输入框：<input ng-model="customSpice">；
6. scope的继承：把controller绑到DOM的不同层级；
7. 外层的scope作为父类，内层的scope作为子类，继承与重写与OOP原理一致；
8. 在最外层的controller之外，是root scope；
9. 控制器的测试：参见UT（略）

chapter 5 服务
1. 服务对象是使用DI包绕在一起的可取代对象，可以跨app共享代码；
2. 懒加载：只有有依赖时才加载服务；
3. 单例：一个组件对服务有依赖时，通过服务工厂得到对这个服务对象的一个引用；
4. 内置服务以$开头；
5. 控制器、filter、服务、指令都可以依赖服务对象；
6. 使用module.factory("服务名"，【依赖..., 服务工厂函数】)，服务工厂函数返回函数或对象；
7. 解释6：注册服务名，服务工厂函数；
8. 依赖申明的顺序与工厂函数的顺序一致；
9. 使用$provider去注册一个服务，常用于UT，格式如下：
   angular.module('myModule', []).config(['$provide', function($provide) { ｝
10. UT： Jasmine spy (mock) 略

chapter 6 scope对象
1. scope: 是应用模型的对象引用，是表达式的执行上下文。多层scope模拟了DOM的层级结构，可以watch表达式，传播事件；
2. 特点：
   a. 提供$watch服务，观察模型变化；
   b. 提供$apply服务，传播事件直达视图层；
3. 子scoope: 继承父scope；
4. 孤scope: (见directive chapter 13)；
5. 表达式依赖一个具体的scope才有意义；
scope是数据模型
1. 在模板链接阶段，指令会在scope上设一个watch，如果scope值有变化，watch就会知会指令，到DOM上去渲染更新的值；
2. 控制器和指令都有指向scope的引用，但控制器和指令相互之间没有引用，控制器对视图不可知；
3. 当scope属性绑定到input组件时，组件值变化时，scope属性会自动更新；
4. scope是视图数据的唯一来源；
scope的层级结构：
1. 每个app只有一个根scope，但有若干个子scope；
2. 应用可以有多个scope，一些指令也会创建新的scope，有层级关系；
3. 最终，scope会形成一棵树，与DOM树并存；
4. 子scope原型继承父scope，直到root scope;
从DOM中获取scope
1. ng-app定义了root scope;
2. 右击元素-》检查-》console-> angular.element($0).scope() 或 $scope
scope的事件传播
1. scope的事件传播类似于DOM事件，向下传给子$broadcast('MyEvent')或向上$emit('MyEvent')传给父；
scope的生命周期
1. $injector启动应用，创建root scope，链接模板，指令会生成子scope；
2. 在链接模板时，指令把watch注册到scope；
3. scope.$apply()观察模型的变化（对开发者隐藏）； 注：除非实现定制的事件回调或第三方库回调，才会写scope.$apply()
   同步：controller，异步： $http, $timeout or $interval
4. $apply之后进入$digest阶段，从根scope开始，到子scope都遍历调用$digest服务;
   在$digest服务中，通过watch查检model变化（脏检查），若有，调用watch listener;
5. 子scoope不再被需要，它的创建者调用 scope.$destroy()销毁对象，中止$digetst传播,回收内存；
scope与指令
1. 编译阶段，编译器基于DOM模板匹配指令，指令两类；
2. 观察式指令，如{{}}，使用 $watch()的监听器，表达式变化之后，它们被通知；
3. 监听式指令，如ng-click注册到DOM的监听器；点击-》触发监听-》$apply回调-》修改model-》watch-》视图; 外部事件
创建scope的指令
1. 查看任一DOM元素的scope:  angular.element(aDomElement).scope();
2. ng-controller 和 ng-repeat会创建子scope;
3. 其它元素不创建scope;
控制器与scope:
1. 控制器通过scope给模板暴露方法；
2. 控制器定义改变模型（即scope的属性）的方法；    
3. 控制器可以在model上注册watch，控制器行为完成后，watch立即执行；
Scope $watch
1. 脏检查时，不访问DOM，只对比js对象的属性，效率高；
2. $watch的三种方式：
   a. 通过引用：scope.$watch (watchExpression, listener)  只检查watchExpression的整体返回值，如果返回值是数组或对象，内部变化不检查；最有效
   b. 通过集合内容：scope.$watchCollection (watchExpression, listener) 当数组或对象内部的项有新增、删除、重排序时，被检查到。 只查第一层，类似于浅拷贝；代价高
   c. 通过值：scope.$watch (watchExpression, listener, true) 检查任何变化；代价最高
集成浏览器的事件环
1. angularjs与浏览器事件环的交互：
   a. 浏览器的事件环等待外部事件；
   b. 外部事件到达后进入js回调，在js上下文中可修改DOM；
   c. 回调结束，浏览器离开js上下文，基于DOM变化重新渲染视图；
2. 以angularjs的方式重新描述1:
   前置： 同1(a)
   a. 调用scope.$apply(stimulusFn)进入angular上下文；stimulusFn是你想做的事;
   b. 执行stimulusFn，修改应用状态；
   c. 进入$digest循环（大环），内含两个小环，一个是 $evalAsync队列(queue)，一个是 $watch列表(list),
      大环一直循环到model稳定，即$evalAsync队列为空，且$watch列表不再检测到变化:
   d. $evalAsync队列: 当前栈帧以外有一些工作需要调度，由$evalAsync队列完成，避免UI闪烁；
   e. $watch列表: 是一套表达式，大循环可导致表达式值改变，引起$watch调用，修改DOM；
   f. 大循环完成，进入1(c)
*************************************
scope.$parent指向scope的父作用域；
scope.$$childHead指向scope的第一个子作用域；
scope.$$childTail指向scope的最后一个子作用域；
scope.$$nextSibling指向scope的下一个相邻作用域；
scope.$$prevSibling指向scope的上一个相邻作用域；
*************************************
   
   
chapter 7 依赖注入
1. injector子系统掌管组件创建，分析依赖，按需提供依赖；
DI在angular中无处不在
1. services, directives, filters, 和animations：通过可注入的工厂方法或构造函数创建，可注入组件：服务、值；
2. Controllers：通过构造函数创建，可注入组件：服务，值，特别依赖；
3. run方法：接受一个函数，该函数可注入组件：服务，值，常量，不能注入provider.
4. config方法：接受一个函数，该函数可注入组件：provider，常量，不能注入服务和值组件；
工厂方法：//depService指依赖的服务
1. 定义服务: angular.module('myModule', []).factory('serviceId', ['depService', function(depService) {  // ...}])
2. 定义指令：angular.module('myModule', []).directive('directiveName', ['depService', function(depService) {  // ...}])
3. 定义filter: angular.module('myModule', [])..filter('filterName', ['depService', function(depService) {  // ...}]);
4. 以上方法完成后，都返回module，以方便链式编程；
Module方法（指config和run方法）：
1. angular.module('myModule', []).config(['depProvider', function(depProvider) {  // ...}])
2. angular.module('myModule', [])..run(['depService', function(depService) {  // ...}]);
控制器定义的数组式标记法
1. someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) {//...}]);
2. 对同一个app，服务是单例的，同一种类型的控制器可以有多个实例；
3. $scope: 控制器是被绑定到DOM的某个元素，所以可依赖scope；其它组件如服务只能依赖root scope;
4. resolves: 如果控制器是作为route的一部分被实例化的，那么任何做为route构成部分的值都可注入到控制器；
依赖注解
1. angular使用injector调用服务工厂和控制器，而这些调用又有依赖，有三种方式告之injector这些依赖：
2. 方式一：内联数组标记法(推荐)：someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) {  // ...}]);
   第二个参数是数组，数组最后一个是函数，函数参数序与依赖相同；
3. 方式二：$inject属性标记法：
	var MyController = function($scope, greeter) {  // ...}  //定义一个普通函数对象
	MyController.$inject = ['$scope', 'greeter'];  //给这个函数对象的$inject属性加入依赖数组
	someModule.controller('MyController', MyController); // 定义控制器
4. 方式三：隐式标记法，假设参数名就是函数名;
  【一般不推荐，若使用minifiers/obfuscators等js工具，会出错，想避免的话使用 ng-annotate工具和ng-strict-di】
使用严格依赖注入模式
1. 在使用ng-app的那个元素上加上ng-strict-di指令；　<html ng-app="myApp" ng-strict-di>
2. 当使用隐式标记法时，严格模式会抛异常；
3. 手工启动时在配置项中加入的方式： angular.bootstrap(document, ['myApp'], {strictDi: true});　
为什么使用DI
1. 组件（对象或函数）有三种方式取得依赖（前两种是硬编码，难于修改，难于测试）：
	a. 组件使用new运算符创建依赖；
	b. 组件通过引用全局变量查找依赖；
	c. 当它需要的时候，依赖会传给它；
2. injector是一个service locator，它负责构造和查找依赖；
3. angularjs编译模板时，会处理ng-controller指令，进而要求injector创建controller实例，进而处理依赖；
   要点：ng-controller->injector->controller实例和依赖； controller实例本身不知道injector的存在；
********************************************************************************************************************************************************
More formally, the Law of Demeter for functions requires that a method m of an object O may only invoke the methods of the following kinds of objects:[2]

O itself
m's parameters
Any objects created/instantiated within m
O's direct component objects
A global variable, accessible by O, in the scope of m   
********************************************************************************************************************************************************

chapter 8 模板
1. 概念: 包含了angularjs的元素和属性的html;
2. 可使用的元素和属性：
   a. 指令，有些指令元素看上去与html元素相同，但是是增强过的，如form，input，a，select，textarea;
   b. Markup: 即{{表达式}};
   c. Filter: 格式化显示数据；
   d. Form controls: 验证用户输入
3. 单页应用：基于$route配置，通过ngView指令，在一个主页中的不同部分，加载一小段模板代码（partials），以显示多个视图；

chapter 9 表达式
1. 概念：一小段js类的代用，主要用于插值绑定；{{ 值表达式 }}，ng-click="函数设用表达式"
2. angularjs表达式 vs js表达式
   a. js基于全局window，angularjs基于scope;
   b. 计算未定义的属性，js生成引用错误或类型错误，angularjs生成null或undefined，没js那么严厉（Forgiving）;
   c. angularjs表达式不能使用条件，循环，或抛常，除了三目操作符；
   d. angularjs表达式不能做函数申明或正则表达式创建；
   e. angularjs表达式不能使用new创建对象；
   f. angularjs表达式不能使用',',‘void’操作符；
   g. 可以使用filter;
3. 计算angularjs表达式：$eval(angularjs表达式)
4. $parse服务： $parse(String expression to compile), var getter = $parse('user.name'); 转angular表达式为函数；
5. window-》$window, location->$location， angularjs表达式不访问window,location,document等传统全局对象；
6. 可以使用this；
7. 局部对象可以使用$locals；
*********************************************
selfReferential: {
    'this': {type: AST.ThisExpression },
    '$locals': {type: AST.LocalsExpression }
  }
*********************************************
8. $event: 即jQuery中的Event Object，在使用 ngClick或ngFocus时会暴露在指令的scope中。
9. 一次性绑定：以‘::’开头的表达式是一次性表达式； {{::name}}   {{name}}
10. 一次性绑定用于注销或释放资源，减少watch的表达式的数量，使得digest过程更快；
11. 适用场合：一旦设置，不可改变的地方；
12. 一次性表达式值稳定算法原理(了解)：
   a. 假设表达式以::开头，进入digest循环，表达式做脏检查，存值为V；
   b. 若V不是未定义，标记表达式为‘稳定’，当退出digest循环时，起一个调度任务去注销对这个表达式的watch;
   c. 处理digest循环至结束；
   d. 当digest循环结束时，所有的值都已处理，继续处理注销watch的任务队列；
      对于每一个将被注销的watch，计算对应的表达式是否仍不是未定义的，如果是这种情况，销注watch;
	  否则，不注销watch，以便在下次digest循环时继续做脏检查；

chapter 10 Interpolation与数据绑定
1. 用于给文件结节或属性值提供数据绑定；<a ng-href="img/{{username}}.jpg">Hello {{username}}!</a>  //插值符号，即{{}}
2. 原理：编译时，编译器使用 $interpolate查看文本节点和属性是否有{{表达式}}，如果有，它给节点加一个插值指令，
   并给插值函数加一个watch。这样，在digest周期时就会更新对应文本节点和属性的值。插值指令优先级100,每个链接都设置一个watch；
3. 绑定到bool属性：  ng-disabled, ng-required, ng-selected, ng-checked, ng-readOnly , ng-open;
   错误：<button disabled="{{isDisabled}}">Disabled</button>
   正确：<button ng-disabled="isDisabled">Disabled</button>;   //ng-disabled="angular表达式"，这里不用插值符号；
4. 使用ngAttr绑定到任意属性
   a. 使用ng-attr-【属性名】;
      原理：$interpolate的allOrNothing标记此时会派上用场，如果插值字符中的任何表达式导致了未定义，属性将会被移除；
   b. 如果原属性名是骆驼风格的，如viewBox，改写为下划线风格，如ng-attr-view_box；
   c. 一般可使用原属性名，若出现问题，就可以试下ngAttr。
     如<select ng-attr-size={{name}}>，
	   <textarea ng-attr-placeholder={{name}}>，
       <button ng-attr-type={{type}}>	   
5. 指令的属性要么是表达式，要么是{{表达式}}，禁止在表达式中再用插值符号，可能出现难以定位的错误；
   例如：<div ng-show="form{{$index}}.$invalid"></div>
6. 在模板中，用this表示scope;  //<div ng-show="this['form' + $index].$invalid"></div>
	  
chapter 11 filter 
1. 格式化显示的值，用于视图模板，控制器或服务；
2. 底层的API是filterProvider；
3. 用于视图模板：{{ expression | filter }}
   e.g.:{{ 12 | currency }} 显示$12.00，
   完整用法：{{ currency_expression | currency : symbol : fractionSize}}
4. filter的链式使用：{{ expression | filter1 | filter2 | ... }}
5. 带参数的filter: {{ expression | filter:argument1:argument2:... }}
   e.g.{{ 1234 | number:2 }} 显示 1,234.00




*****************************************************************************
API自带的filter:
currency： 格式化货币
date：所有年月日时分秒毫秒上午下午时区周纪元等
filter：从数组中选一个子集，返回一个新数组
json：转js对象到json的字符串
limitTo：在数组或字符串或数字中，从头开始或从尾开始，取指定个数元素，创建新数组或字符串；
lowercase：转小写
number：格式化数字为文本；
orderBy：对指定数组排序；
uppercase：转大写
*****************************************************************************   

chapter 12 forms
chapter 13 指令
chapter 14 组件
chapter 15 组件路由
chapter 16 动画
chapter 17 模块
chapter 18 HTML编译器
chapter 19 provider
chapter 20 启动
chapter 21 单元测试（略）
chapter 22 端到端测试（略）
chapter 23 $location服务
chapter 24 使用css
chapter 25 国际化（略）
chapter 26 安全

chapter 27 Accessibility（to persons with disabilities，略）
chapter 28 IE兼容性
1. angularjs1.2版本支持到IE8；
2. angularjs1.3-1.55版本支持到IE9及以上版本；
3. 使用ng-style，而不是style="{{ someCss }}"；
4. 错误：<button type="{{someExpression}}"">Disabled</button>
   正确：<button ng-attr-type="{{someExpression}}"">Disabled</button>

chapter 29 产品环境运行

chapter 30 迁移（略）




























